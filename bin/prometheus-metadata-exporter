#!/usr/bin/env ruby
# coding: utf-8

require 'metadata/checker'
require 'metadata/saml/parser'
require 'metadata/saml/client'
require 'metadata/expiry/certificate_result'
require 'mixlib/cli' # pulled in implicitly by the sensu gem
require 'prometheus/middleware/exporter'
require 'sinatra/base'

class ExpiryDateMetric < Prometheus::Client::Gauge
  def initialize(metadata_url)
    super(:verify_federation_certificate_expiry, "The NotAfter date of the given X.509 SAML certificate")
    @metadata_url = metadata_url
    @metadata_client = Metadata::SAML::Client.new
    @parser = Metadata::SAML::Parser.new
    @certificate_factory = Metadata::Certificate::CertificateFactory.new
  end
  def values
    # we're being scraped

    # we create a new gauge each time to avoid keeping metrics for
    # certificates which have been removed from metadata
    gauge = Prometheus::Client::Gauge.new(name, docstring)
    document = @metadata_client.get(@metadata_url, false)
    certificate_identities = @parser.certificate_identities(document)
    certificate_identities.each do | pem, entity |
      cert = @certificate_factory.from_inline_pem(pem)
      # grafana prefers timestamps to be in milliseconds :(
      not_on_or_after = cert.not_after.to_time.to_f * 1000
      entity.each do |e|
        gauge.set({entity_id: e[:entity_id], key_use: e[:key_use], key_name: e[:key_name], serial: cert.serial}, not_on_or_after)
      end
    end

    # return the metrics to prometheus
    return gauge.values
  end
end

# ocsp - same as ExpiryDateMetric but 0 (fail) or 1 (pass)
class OcspCheckMetric < Prometheus::Client::Gauge
  def initialize(metadata_url, ca_files)
    super(:verify_federation_certificate_ocsp_success, "If an OCSP check of the given X.509 SAML certificate is good (1) or bad (0)")
    @metadata_url = metadata_url
    @ca_files = ca_files
    @metadata_client = Metadata::SAML::Client.new
    @parser = Metadata::SAML::Parser.new
    @certificate_factory = Metadata::Certificate::CertificateFactory.new
    @pem_checker = Metadata::Ocsp::PemChecker.new
  end
  def values
    # we're being scraped

    # we create a new gauge each time to avoid keeping metrics for
    # certificates which have been removed from metadata
    gauge = Prometheus::Client::Gauge.new(name, docstring)
    document = @metadata_client.get(@metadata_url, false)
    certificate_identities = @parser.certificate_identities(document)

    pems = certificate_identities.keys
    ocsp_results = @pem_checker.check_pems(pems, @ca_files)
    certificate_identities.map do |pem, identities|
      identities.map do |identity|
        gauge.set({entity_id: identity.entity_id, key_use: identity.key_use, key_name: identity.key_name, serial: @certificate_factory.from_inline_pem(pem).serial}, ocsp_results[pem].revoked? ? 0 : 1)
      end
    end

    # return the metrics to prometheus
    return gauge.values
  end
end

class PrometheusMetadataExporter
  include Mixlib::CLI

  option :port, :short => '-p PORT', required: false, default: 9199
  option :host, :short => '-h HOST', required: true
  option :ca_file_list, :long => '--cas FILES', required: true

  def gogogo
    Prometheus::Client::registry.register(ExpiryDateMetric.new(config[:host]))
    Prometheus::Client::registry.register(OcspCheckMetric.new(config[:host], config[:ca_file_list].split(",")))
  end
end

class App < Sinatra::Base
  use Prometheus::Middleware::Exporter

  exporter = PrometheusMetadataExporter.new
  exporter.parse_options

  set :port, exporter.config[:port]
  set :bind, '0.0.0.0'

  exporter.gogogo
  run! if app_file == $0
end


