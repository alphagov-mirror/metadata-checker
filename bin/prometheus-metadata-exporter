#!/usr/bin/env ruby
# coding: utf-8

require 'metadata/checker'
require 'metadata/saml/parser'
require 'metadata/saml/client'
require 'metadata/expiry/certificate_result'
require 'mixlib/cli' # pulled in implicitly by the sensu gem
require 'prometheus/middleware/exporter'
require 'sinatra/base'

class ExpiryDateMetric < Prometheus::Client::Gauge
  def initialize(metadata_url, metadata_expected_to_be_signed)
    super(:verify_federation_certificate_expiry, "The NotAfter date of the given X.509 SAML certificate")
    @metadata_url = metadata_url
    @metadata_client = Metadata::SAML::Client.new
    @parser = Metadata::SAML::Parser.new
    @certificate_factory = Metadata::Certificate::CertificateFactory.new
    @metadata_expected_to_be_signed = metadata_expected_to_be_signed
  end
  def values
    # we're being scraped

    # we create a new gauge each time to avoid keeping metrics for
    # certificates which have been removed from metadata
    gauge = Prometheus::Client::Gauge.new(name, docstring)
    document = @metadata_client.get(@metadata_url, false)

    # these are all the certs served from the metadata
    check_and_set(gauge, @parser.certificate_identities(document))

    # this is the cert used to sign the metadata document itself
    if @metadata_expected_to_be_signed
        signing_cert = @parser.signing_certificate(document)
        check_and_set(gauge, signing_cert) unless signing_cert.nil?
    end

    # return the metrics to prometheus
    return gauge.values
  end

  private

  def check_and_set(gauge, certificate_identities)
    certificate_identities.each do | pem, entity |
      cert = @certificate_factory.from_inline_pem(pem)
      # grafana prefers timestamps to be in milliseconds :(
      not_on_or_after = cert.not_after.to_time.to_f * 1000
      entity.each do |e|
        gauge.set({entity_id: e[:entity_id], use: e[:key_use], key_name: e[:key_name], serial: cert.serial}, not_on_or_after)
      end
    end
  end

end

# ocsp - same as ExpiryDateMetric but 0 (fail) or 1 (pass)
class OcspCheckMetric < Prometheus::Client::Gauge
  def initialize(metadata_url, ca_files, metadata_ca_files)
    super(:verify_federation_certificate_ocsp_success, "If a cert chain validation and OCSP check of the given X.509 SAML certificate is good (1) or bad (0)")
    @metadata_url = metadata_url
    @ca_files = ca_files
    @metadata_ca_files = metadata_ca_files
    @metadata_client = Metadata::SAML::Client.new
    @parser = Metadata::SAML::Parser.new
    @certificate_factory = Metadata::Certificate::CertificateFactory.new
    @pem_checker = Metadata::Ocsp::PemChecker.new
  end
  def values
    # we're being scraped

    # we create a new gauge each time to avoid keeping metrics for
    # certificates which have been removed from metadata
    gauge = Prometheus::Client::Gauge.new(name, docstring)
    document = @metadata_client.get(@metadata_url, false)

    # these are all the certs served from the metadata
    check_and_set(gauge, @parser.certificate_identities(document), @ca_files)

    # this is the cert used to sign the metadata document itself
    check_and_set(gauge, @parser.signing_certificate(document), @metadata_ca_files) unless @metadata_ca_files.length == 0

    # return the metrics to prometheus
    return gauge.values
  end

  private

  def check_and_set(gauge, certificate_identities, ca_files)
      pems = certificate_identities.keys
      ocsp_results = @pem_checker.check_pems(pems, ca_files)
      certificate_identities.map do |pem, identities|
        identities.map do |identity|
          gauge.set({entity_id: identity.entity_id, use: identity.key_use, key_name: identity.key_name, serial: @certificate_factory.from_inline_pem(pem).serial}, ocsp_results[pem].revoked? ? 0 : 1)
        end
      end
  end
end

class PrometheusMetadataExporter
  include Mixlib::CLI

  option :port, :short => '-p PORT', required: false, default: 9199
  option :host, :short => '-h HOST', required: true
  option :ca_file_list, :long => '--cas FILES', required: true
  option :metadata_ca_file_list, :long => '--metadata_cas FILES', required: false

  def gogogo
    metadata_ca_file_list = []
    metadata_ca_file_list = config[:metadata_ca_file_list].split(",") unless config[:metadata_ca_file_list].nil?
    Prometheus::Client::registry.register(ExpiryDateMetric.new(config[:host], metadata_ca_file_list.length>0))
    Prometheus::Client::registry.register(OcspCheckMetric.new(config[:host], config[:ca_file_list].split(","), metadata_ca_file_list))
  end
end

class App < Sinatra::Base
  use Prometheus::Middleware::Exporter

  exporter = PrometheusMetadataExporter.new
  exporter.parse_options

  set :port, exporter.config[:port]
  set :bind, '0.0.0.0'

  exporter.gogogo
  run! if app_file == $0
end


